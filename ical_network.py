# code to organize meeting invitations into networks

# imports

import itertools
from icalendar import Calendar, Event, vCalAddress, vText
from datetime import datetime, date
import networkx as nx

# =================================
# Person objects represent the nodes in the graphs;
# later we can give them whatever attributes, right now i'm just coloring them

default_colors = {'gmail.com': {'r': 39, 'g': 105, 'b': 255, 'a': 0.5},
            'defaultcolor': {'r': 100, 'g': 100, 'b': 100, 'a':  0.5}}
            

class Person:
    def __init__(self, name, colors = default_colors):
        self.name = name
        for identifier in colors:
            if identifier in name:
                self.color = colors[identifier]
                self.group = identifier
        if not hasattr(self, 'group'):
            try:
                self.color = colors['defaultcolor']
            except:
                self.color = {'r': 100, 'g': 100, 'b': 100, 'a':  0.5}
            self.group = ''
            
        
# =================================
# load ical files, get meetings, get people
        
class Meeting:
    # each Meeting represents a single icalendar event, and the implicated Persons
    
    def __init__(self, uid, host, attendees, time, info, droids=['calendar.google.com']):
        self.uid = uid
        self.host = host.replace('mailto:', '')
        if isinstance(attendees, str): # fix for one-prson meetings
            attendees = [attendees]
        self.attendees = [name.replace('mailto:', '') for name in attendees]
        self.date = time.dt
        try:
            self.date = self.date.date()
        except:
            pass
        self.info = info

        # flag any hosts or attendees we don't want to make into nodes
        if any(droid in self.host for droid in droids):
            self.host = 'droid'
        self.attendees = [a for a in self.attendees if not any(droid in a for droid in droids)]
        
        if self.host not in self.attendees:
            if self.host != 'droid':
                self.attendees.append(self.host)
            
    def connects(self):
        # a list of every pair of attendees - these will be the edges in our network
        cc = itertools.combinations(self.attendees, 2)
        return [[c[0], c[1]] for c in cc]
        
        
def load_single_ical(filename, droids = ['calendar.google.com']):
    # this grabs each event from the ical file, records it as a Meeting, 
    # and outputs [Meeting1, Meeting2...]
    meetlist = []
    cal = open(filename, 'rb')
    ecal = Calendar.from_ical(cal.read())
    for comp in ecal.walk():
        if comp.name == "VEVENT":
            try:
                meetlist.append(Meeting(comp['UID'], comp['ORGANIZER'], comp['ATTENDEE'], 
                            comp['DTSTART'], comp['SUMMARY'], droids = droids))
            except KeyError:
                pass # if a calendar vevent does not have these keys, it's not a meeting
    cal.close()
    return meetlist
     
    
def find_people(meetings, colors = default_colors, blocklist = ['droid']):
    # generate a list of Persons based on the name list; can give them a node color based 
    # on their email address using colors = {}.
    # some names are already set to 'droid' (not people) on initiating Meetings.
    # any other names to be filtered out can be added to blocklist = [].
    names = []
    people = []
    for n in range(len(meetings)):
        names = names + meetings[n].attendees
    names = list(set(names)) # kill duplicates
    for name in names:
        if name not in blocklist:
            people.append(Person(name, colors = colors))
    return people
    
    
def combine_meetings(meeting_lists):
    # combines all meetings in two or more meetlists, as generated by load_single_ical()
    comblist = meeting_lists[0]
    uids = [m.uid for m in comblist]
    n_match = 0
    print('first list len: ', len(uids))
    for meetlist in meeting_lists[1:]:
        print('new list len: ', len(meetlist))
        for meeting in meetlist:
            if meeting.uid not in uids:
                comblist.append(meeting)
                uids.append(meeting.uid)
            else:
                n_match += 1
        print('duplicate uids: ', n_match)
        print('new length: ', len(comblist))
    return comblist
    
    
# =================================
# filtering meetings


def filter_meetings(meetings, dates = ['2000-01-01', '2050-12-31']):
    # filter a list of Meetings by time range, ...
    
    dates = [date.fromisoformat(dates[0]), date.fromisoformat(dates[1])]
    meetings = [m for m in meetings if m.date > dates[0]]
    meetings = [m for m in meetings if m.date < dates[1]]
    return meetings
    
                  
# =================================
# generating graphs and exporting

def setup_nodes(people):
    g = nx.Graph()
    for person in people:
        g.add_node(person.name, group = person.group, viz={'color':person.color})
    return g
    
    
def setup_edges(g, meetings):
    # should be run after setup_nodes(). these steps need to be separate for blocklist
    # to work properly!
    for meeting in meetings:
        for connect in meeting.connects():
            if g.has_node(connect[0]) and g.has_node(connect[1]): # avoid adding nodes!
                if g.has_edge(connect[0], connect[1]):
                    g[connect[0]][connect[1]]['weight'] += 1.
                    g[connect[0]][connect[1]]['info'] += ' ' + str(meeting.info) + '\n'
                else:
                    g.add_edge(connect[0], connect[1], weight = 1, 
                                info = str(meeting.info))
    return g
    
    
def make_graph(people, meetings, filename = "outputs/con.gexf", write = True):
    # this sets up the network, and writes result to a gephi file
    # people : a list of Person objects
    # meetings: a list of Meeting objects, with attendee names matching some Person.name
    g = setup_nodes(people)
    g_e = setup_edges(g, meetings)
    if write:
        nx.write_gexf(g_e, filename)
    return g_e