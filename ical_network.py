# code to organize calendar meeting invitations into networks

# current overall structure:

# 1) we load Meeting objects directly from the ical file, mlist = load_single_ical(file)

# 2) we combine lists of Meetings if need be, combine_meetings([mlist1, mlist2 ...])

# 3) we filter lists of Meetings e.g. for date ranges using filter_meetings()

# 4) we make a list of People based on the meeting list, plist = find_people(mlist)

# 5) we make the network based on lists of Meetings and People, make_graph(plist, mlist)

# step 4 could probably be merged with 5 tbh :)

# testing:
# there are some unittests based on fake data in test_ical_network.py
# we can e.g. run them all from command line with nose2, >> python -m nose2

# =================================
# imports

import itertools
from icalendar import Calendar, Event, vCalAddress, vText
from datetime import datetime, date
import networkx as nx
from collections import Counter
        
# =================================
# load ical files, get meetings
        
class Meeting:
    # each Meeting represents a single icalendar event, and the implicated Persons
    
    def __init__(self, uid, organizer, attendees, aa_types, aa_partstat, time, summary,
                    description = '', organizer_blocklist = ['calendar.google.com']):
        self.uid = uid
        self.summary = summary
        self.description = description
        if isinstance(attendees, str): # fix for one-person meetings
            attendees = [attendees]
        self.organizer = organizer.replace('mailto:', '')
        attendees = [name.replace('mailto:', '') for name in attendees]
        
        # remove time-of-day and tzone information, if present; makes filtering simpler.
        self.date = time.dt
        try:
            self.date = self.date.date()
        except:
            pass

        # processing attendees
        self.attendees = []
        for n in range(len(attendees)):
            if aa_types[n] != 'RESOURCE':  # removes calendar apps etc. as participants
                if aa_partstat[n] != 'DECLINED': # removes people who actively declined
                    self.attendees.append(attendees[n])

        # add the organizer to attendees list if they are human and not already in it.
        # the explicit blocklist seems needed as organizers usually lack ['CUTYPE']
        if self.organizer in organizer_blocklist:
            self.organizer = 'droid'
        if self.organizer not in self.attendees:
            if self.organizer != 'droid':
                self.attendees.append(self.organizer)
            
    def connects(self):
        # a list of every pair of attendees present - these are the edges in our network
        cc = itertools.combinations(self.attendees, 2)
        return [[c[0], c[1]] for c in cc]


def load_single_ical(filename, organizer_blocklist = ['calendar.google.com']):
    # this grabs each event from the ical file, records it as a Meeting, 
    # and outputs [Meeting1, Meeting2...]
    
    meetlist = [] 
    cal = open(filename, 'rb')
    ecal = Calendar.from_ical(cal.read())
    for event in ecal.events:
        try:
            uid = event['UID']
            organizer = event['ORGANIZER']
            attendees = event['ATTENDEE']
            aa_types = [event['ATTENDEE'][n].params['CUTYPE'] for n in range(len(event['ATTENDEE']))]
            aa_partstat = [event['ATTENDEE'][n].params['PARTSTAT'] for n in range(len(event['ATTENDEE']))]
            time = event['DTSTART']
            summary = event['SUMMARY']
            try:
                description = event['DESCRIPTION']
            except:
                description = ''
            meetlist.append(Meeting(uid, organizer, attendees, aa_types, aa_partstat,
                            time, summary, description = description, 
                            organizer_blocklist = organizer_blocklist))
        except:
            pass # if an event doesn't have these keys, it's not a meeting.
    cal.close()
    return meetlist
    
    
# =================================
# processing meetings-lists

def combine_meetings(meeting_lists, verbose = True):
    # combines all meetings in two or more meetlists, as generated by load_single_ical()
    # discards duplicate meetings based on the UID
    comblist = meeting_lists[0]
    uids = [m.uid for m in comblist]
    n_match = 0
    if verbose:
        print('first list len: ', len(uids))
    for meetlist in meeting_lists[1:]:
        if verbose:
            print('new list len: ', len(meetlist))
        for meeting in meetlist:
            if meeting.uid not in uids:
                comblist.append(meeting)
                uids.append(meeting.uid)
            else:
                n_match += 1
        if verbose:
            print('duplicate uids: ', n_match)
            print('new length: ', len(comblist))
    return comblist


def filter_meetings(meetings, dates = ['2000-01-01', '2050-12-31'], no_repeats = False,
                        filter_group = 'None', min_attendees = 1):
    # filter a list of Meetings by: 
    # date,  range dates = [] 
    # whether one or 2+ workgroups are involved, filter_group = 'single' or = 'multi'
    # min_attendees =  filter out meetings with less attendees than this
    # no_repeats = : filters out repeating meetings (those with identical summaries)
    
    categorize_meetings(meetings)
    
    dates = [date.fromisoformat(dates[0]), date.fromisoformat(dates[1])]
    meetings = [m for m in meetings if m.date > dates[0]]
    meetings = [m for m in meetings if m.date < dates[1]]
    if no_repeats:
        meetings = [m for m in meetings if m.repeating]
    if filter_group == 'single':
        meetings = [m for m in meetings if len(m.groups) == 1]
    if filter_group == 'multi':
        meetings = [m for m in meetings if len(m.groups) > 1]
    if min_attendees > 1:
        meetings = [m for m in meetings if len(m.attendees) > min_attendees - 1]
    return meetings
        

def categorize_meetings(meetings):
    # categorize meetings based on properties of the meeting-list
    
    summaries = [m.summary for m in meetings]
    counts = Counter(summaries)
    for m in meetings:
        m.repeats = counts[m.summary]
        m.repeating = True if counts[m.summary] > 1 else False
        m.groups = list(set([a.partition('@')[2] for a in m.attendees]))
        

# =================================
# Person objects represent the nodes in the graphs;
# later we can give them whatever attributes, right now i'm just coloring them

default_colors = {'gmail.com': {'r': 39, 'g': 105, 'b': 255, 'a': 0.5},
            'defaultcolor': {'r': 100, 'g': 100, 'b': 100, 'a':  0.5}}
            

class Person:
    def __init__(self, name, colors = default_colors):
        self.name = name
        for identifier in colors:
            if identifier in name:
                self.color = colors[identifier]
                self.group = identifier
        if not hasattr(self, 'group'):
            try:
                self.color = colors['defaultcolor']
            except:
                self.color = {'r': 100, 'g': 100, 'b': 100, 'a':  0.5}
            self.group = ''
            
            
def find_people(meetings, colors = default_colors, blocklist = ['droid']):
    # generate a list of Persons based on the name list; can give them a node color based 
    # on their email address using colors = {}.
    # some names are already set to 'droid' (not people) on initiating Meetings.
    # any other names to be filtered out can be added to blocklist = [].
    names = []
    people = []
    for n in range(len(meetings)):
        names = names + meetings[n].attendees
    names = list(set(names)) # kill duplicates
    for name in names:
        try:
            domain = name.split('@', 1)[1]
        except:
            domain = name
        if name not in blocklist:
            if domain not in blocklist:
                people.append(Person(name, colors = colors))
    return people
        
                  
# =================================
# generating graphs and exporting

def setup_nodes(people):
    # the 'setup nodes' and 'setup edges' steps should be kept separate, due to blocklist.
    g = nx.Graph()
    for person in people:
        g.add_node(person.name, group = person.group, viz={'color':person.color})
    return g
    
    
def setup_edges(g, meetings, downweight_repeats = False):
    # should be run after setup_nodes(). 
    for meeting in meetings:
        weight_inc = 1
        if downweight_repeats:
            weight_inc = 1./meeting.repeats
        for connect in meeting.connects():
            if g.has_node(connect[0]) and g.has_node(connect[1]): # avoid adding nodes!
                if g.has_edge(connect[0], connect[1]):
                    g[connect[0]][connect[1]]['weight'] += weight_inc
                    g[connect[0]][connect[1]]['summary'] += ' ' +str(meeting.summary)+'\n'
                    g[connect[0]][connect[1]]['description'] += ' ' +str(meeting.description)+'\n'
                else:
                    g.add_edge(connect[0], connect[1], weight = weight_inc, 
                                summary = str(meeting.summary) +'\n',
                                description = str(meeting.description) +'\n')
    return g
    
    
def make_graph(people, meetings, filename = "outputs/con.gexf", write = True,
                min_connections = 1, downweight_repeats = False, verbose = True):
    # this sets up the network, and writes result to a gephi file
    
    # people : a list of [Person1, Person2...]
    # meetings: a list of [Meeting1, Meeting2], with attendees matching some Person.name
    
    # min_connections = : discard any edges that have less unique meetings than this
    
    # downweight_repeats = bool
    # 'repeat' meetings are those that have identical summaries in the meeting list. 
    # (i do it this way because the ical repeat flag seems very inconsistent!)
    # if True, this weights repeat meetings as 1/n, where n is the number of repetitions.
    
    try:
        check = meetings[0].repeating
    except:
        categorize_meetings(meetings) # some functionality needs the m.repeating set.
    
    g_n = setup_nodes(people)
    
    g_e = setup_edges(g_n, meetings, downweight_repeats)
    
    # remove edges that have insufficient connections (i.e. shared meetings), based on
    # min_connections = 
    to_remove = [(a,b) for a, b, attrs in g_e.edges(data=True) 
                        if attrs["weight"] < min_connections]             
    if len(to_remove) > 0:
        n_edge_initial = g_e.number_of_edges()
        g_e.remove_edges_from(to_remove)
        if verbose:
            print('edges init: ', n_edge_initial, ' remaining: ', g_e.number_of_edges())
        
    # remove isolated nodes
    n_node_initial = g_e.number_of_nodes()
    g_e.remove_nodes_from(list(nx.isolates(g_e)))
    if verbose:
        print('nodes init: ', n_node_initial, ' remaining: ', g_e.number_of_nodes())
        
    if write:
        nx.write_gexf(g_e, filename)
    return g_e
    
    